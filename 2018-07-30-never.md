---
title: Never
author: Mattt
translator: Juan F. Sagasti
category: Swift
excerpt: >
    Afirmar que algo nunca ocurrir√° es como invitar al Universo a probar lo contrario. Por suerte para nosotros, Swift sostiene esa afirmaci√≥n gracias al m√°s improbable de los tipos: `Never`.
status:
    swift: 4.2
---

¬´Nunca¬ª es un adverbio que indica que un evento no ocurre en ning√∫n tiempo pasado o futuro. En el eje del tiempo constituye una imposibilidad l√≥gica; la nada se extiende en todas direcciones. Para siempre.

... por eso es especialmente preocupante encontrarse [este comentario](https://github.com/search?q=%22this+will+never+happen%22&type=Code) en el c√≥digo:

```swift
// esto nunca ocurrir√°
```

Cualquier libro de texto sobre compiladores te dir√° que
un comentario como ese no puede ni afectar√° al comportamiento del c√≥digo compilado.
[La Ley de Murphy](https://es.wikipedia.org/wiki/Ley_de_Murphy) dice lo contrario.

¬øC√≥mo nos mantiene Swift a salvo de todo este caos impredecible que es la programaci√≥n? Aunque no lo creas, la respuesta es: **nada** y _**crashing**_.

---

Se ha propuesto `Never` como sustituto del atributo `@noreturn` en [SE-0102: "Eliminar el atributo @noreturn e introducir un tipo vac√≠o Never"](https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md), por [Joe Groff](https://github.com/jckarter).

Antes de Swift 3, las funciones que deten√≠an la ejecuci√≥n, como `fatalError(_:file:line:)`, `abort()` y `exit(_:)` se anotaban con el atributo `@noreturn`, el cual le indicaba al compilador que no exist√≠a un punto de retorno al √°mbito del que hizo la llamada.

```swift
// Swift < 3.0
@noreturn func fatalError(_ message: () -> String = String(),
                               file: StaticString = #file,
                               line: UInt = #line)
```

Despu√©s del cambio, `fatalError` y sus similares se declararon para devolver el tipo `Never`:

```swift
// Swift >= 3.0
func fatalError(_ message: @autoclosure () -> String = String(),
                     file: StaticString = #file,
                     line: UInt = #line) -> Never
```

Podr√≠a pensarse que reemplazar la funcionalidad de una anotaci√≥n con un tipo puede ser algo muy complejo, ¬øverdad? ¬°Al contrario! `Never` es de los tipos m√°s simples de la librer√≠a est√°ndar de Swift:

```swift
enum Never {}
```

## Tipos vac√≠os

`Never` es un tipo *vac√≠o*, lo que significa que no tiene valores. O dicho de otra forma, no puede construirse.

_Enums_ sin casos son el ejemplo m√°s com√∫n de tipos vac√≠os en Swift. Al contrario que *Structs* y clases, los `enum` no tienen inicializador. Y al contrario que los protocolos, son tipos concretos que pueden tener propiedades, m√©todos, restricciones gen√©ricas y tipos anidados. Por todo ello se usan `enum`  vac√≠os a lo largo de la librer√≠a est√°ndar de Swift para cosas como [la funcionalidad de namespaces](https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918) y [sobre tipos](https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43).

Pero `Never` no es as√≠. No tiene ning√∫n adorno especial. 
Su especial virtud es la de ser lo que es (o mejor dicho, lo que no).

Considera una funci√≥n que devuelva un tipo vac√≠o. Como los tipos vac√≠os no tienen ning√∫n valor, la funci√≥n no puede retornar de manera normal (¬øqu√© retornar√≠a?). En cambio, la funci√≥n debe o parar su ejecuci√≥n o ejecutarse indefinidamente.


## Eliminando estados imposibles en tipos gen√©ricos

`Never` es interesante te√≥ricamente, desde luego. Pero, ¬øqu√© aplicaci√≥n pr√°ctica tiene?
No mucha. O, al menos, no antes de que aceptaran
[SE-0215: Conformar Never a Equatable y Hashable](https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable).

En esta propuesta,
[Matt Diephouse](https://github.com/mdiep) explica la motivaci√≥n que hay detr√°s de hacer que este oscuro tipo conforme `Equatable` y otros protocolos:

> `Never` es muy √∫til a la hora de representar c√≥digo imposible. La gran mayor√≠a est√° familiarizada con este tipo como el tipo que devuelven funciones como `fatalError`, pero tambi√©n es √∫til a la hora de trabajar con clases gen√©ricas. Por ejemplo, un tipo `Result` podr√≠a usar `Never` como su `Value` para representar algo que siempre falla o usar `Never` como su `Error` para representar algo que nunca lo hace.

Swift no tiene un tipo est√°ndar `Result`, pero la mayor√≠a de ellos son similares a √©ste:

```swift
enum Result<Value, Error: Swift.Error> {
    case success(Value)
    case failure(Error)
}
```

Los tipos como `Result` se usan para encapsular valores y errores producidos por funciones que se ejecutan de manera as√≠ncrona (funciones s√≠ncronas pueden usar `throws` para comunicar errores).

Por ejemplo, una funci√≥n que hace una petici√≥n HTTP as√≠ncrona podr√≠a usar un tipo `Result` para almacenar la respuesta o el error:

```swift
func fetch(_ request: Request, completion: (Result<Response, Error>) -> Void) {
    // ...
}
```

Cuando llamas a esa funci√≥n, har√≠as un *switch* sobre `result` para responder a `.success` o `.failure` de forma aislada:

```swift
fetch(request) { result in
    switch result {
    case .success(let value):
        print("Success: \(value)")
    case .failure(let error):
        print("Failure: \(error)")
    }
}
```

Ahora considera una funci√≥n que devuelva siempre con √©xito un resultado en su *completion handler*:

```swift
func alwaysSucceeds(_ completion: (Result<String, Never>) -> Void) {
    completion(.success("yes!"))
}
```

Al especificar `Never` como el tipo `Error` del resultado estamos usando el sistema de tipado para indicar que el fallo no es una opci√≥n. Y es genial que Swift sea lo suficientemente listo para saber que no hay que controlar el caso `.failure` del `switch` para que sea exhaustivo:

```swift
alwaysSucceeds { (result) in
    switch result {
    case .success(let string):
        print(string)
    }
}
```

Se puede ver este efecto aplicado al extremo en la implementaci√≥n de `Never` conformando a `Comparable`:

```swift
extension Never: Comparable {
  public static func < (lhs: Never, rhs: Never) -> Bool {
    switch (lhs, rhs) {}
  }
}
```

Como `Never` es un tipo vac√≠o no hay ning√∫n posible valor de √©l, por lo que al hacer un `switch` sobre `lhs` y `rhs`, Swift entiende que no hay ning√∫n caso faltante por controlar. Y como todos los casos (ninguno en este caso) devuelven `Bool`, el m√©todo compila sin problemas.

_¬°Genial!_

---

## Never como tipo de fondo

A modo de corolario, la propuesta original de Swift Evolution sobre `Never` insin√∫a la utilidad te√≥rica del tipo con mejoras adicionales:

> Un tipo vac√≠o puede verse como un subtipo de cualquier otro tipo: Si evaluar una expresi√≥n no produce nunca un valor, no importa de qu√© tipo sea dicha expresi√≥n.
> Si el compilador soportase esto, permitir√≠a cosas muy √∫tiles.

### _Unwrap_ o muere

El operador de _unwrap_ forzado(`!`) es una de las partes m√°s controv√©rsicas de Swift. 
En el mejor de los casos, es un mal necesario.
En el peor, es un _code smell_ que sugiere descuido.
Y sin informaci√≥n adicional puede ser realmente complicado diferenciar ambos casos.

Por ejemplo, considera el siguiente c√≥digo que asume que un `array` no est√° vac√≠o:

```swift
let array: [Int]
let firstIem = array.first!
```

Para evitar `!` aqu√≠, podr√≠amos usar un `guard` con asignaci√≥n condicional:

```swift
let array: [Int]
guard let firstItem = array.first else {
    fatalError("array cannot be empty")
}
```

Si, en el futuro, se implementa `Never` como un tipo de fondo, podr√≠a usarse en el lado derecho del operador de coalescencia de una expresi√≥n:

```swift
//Swift futuro? üîÆ
let firstItem = array.first ?? fatalError("array cannot be empty")
```

Si te urge la necesidad de adoptar este patr√≥n, puedes sobrecargar el operador `??`:

```swift
func ?? <T>(lhs: T?, rhs: @autoclosure () -> Never) -> T {
    switch lhs {
    case let value?:
        return value
    case nil:
        rhs()
    }
}
```
Sin embargo...

> En la [base l√≥gica](https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222)
> de [SE-0217: Introduciendo el operador !! "Unwrap o Muere" a la Librer√≠a Est√°ndar de Swift](https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps),
> [Joe Groff](https://github.com/jckarter) se√±ala que
> "[...] sobrecargar [?? usando Never] tiene un impacto inaceptable en el rendimiento de la comprobaci√≥n de tipos...". Por tanto, no se recomienda que lo hagas en tu c√≥digo.

### _Throw_ como expresi√≥n

De igual forma, si se cambia `throw` para que sea una expresi√≥n que devuelve `Never`, podr√≠a usarse `throw` en el lado derecho de `??`:

```swift
// Swift futuro? üîÆ
let firstItem = array.first ?? throw Error.empty
```

### _Throws_ tipados

Mirando incluso m√°s all√°: si la palabra clave `throw` soportase restricciones de tipo en la declaraci√≥n de funciones, el tipo `Never` podr√≠a usarse para indicar que una funci√≥n no har√° `throw` (igual que el ejemplo anterior sobre `Result`):

```swift
// Swift futuro? üîÆ
func neverThrows() throws<Never> {
    // ...
}

neverThrows() // `try` innecesario porque se garantiza el √©xito (quiz√°)
```

---

Afirmar que algo nunca ocurrir√° es como invitar al Universo a probar lo contrario. Mientras que la l√≥gica modal o dox√°stica permite un salvoconducto para guardar las apariencias (_"era cierto en aquel momento, ¬°por eso lo cre√≠!"_), la l√≥gica temporal parece estar a un nivel superior a la hora de sostener una afirmaci√≥n. 

Por suerte para nosotros, Swift sostiene esa afirmaci√≥n gracias al m√°s improbable de los tipos: `Never`.
